#version 460

#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_memory_scope_semantics : enable
// #extension GL_EXT_shader_atomic_float : enable
#extension GL_KHR_shader_subgroup_vote : enable
// #extension GL_KHR_shader_subgroup_ballot : enable
#pragma use_vulkan_memory_model

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

struct Split {
    uint i;
    uint j;
    float spill;
};

struct AliasTableEntry {
    float p;
    uint a;
};

layout(set = 0, binding = 0) readonly buffer in_partitions {
    uint heavyCount;
    uint heavyLightIndices[];
};

layout(set = 0, binding = 1) readonly buffer in_weights {
    float weights[];
};

layout(set = 0, binding = 2) readonly buffer in_mean {
    float mean;
};

layout(set = 0, binding = 3) readonly buffer in_splits {
    Split splits[];
};

layout(set = 0, binding = 4) writeonly buffer out_aliastable {
    AliasTableEntry table[];
};

layout(push_constant) uniform PushConstant {
    uint size;
    uint K;
} pc;


// struct CyclicBufferElement {
// };
//
// const uint CyclicBufferMask = 0x1F; // 0x1F == 31 <= 31 + 1 == 32 is power of 2
// const uint CyclicBufferSize = 33;
// struct CyclicBuffer {
//   uint start;
//   uint end;
//   uint size;
// };
//
// void cyclicBuffer_init(out CyclicBuffer self) {
//   self.start = 0;
//   self.end = 0;
// }
//
// bool cyclicBuffer_empty(in CyclicBuffer self) {
//   return self.start == self.end;
// }
//
// uint cyclicBuffer_front(in CyclicBuffer self) {
//   return self.start;
// }
//
// uint cyclicBuffer_back(in CyclicBuffer self) {
//   return self.end;
// }
//
// uint cyclicBuffer_count(in CyclicBuffer self) {
//   return self.start + CyclicBufferSize - self.end;
// }
//
// void cyclicBuffer_pushFront(in CyclicBuffer self, out uint idx) {
//   idx = self.start;
//   self.start = (self.start + 1) & CyclicBufferMask;
// }
//
// void cyclicBuffer_popBack(in CyclicBuffer self) {
//   self.end = (self.end + 1) & CyclicBufferMask;
// }
//
// struct ChunkElement {
//   uint index;
// };
//
// const uint ChunkSize = CyclicBufferSize;
// struct Chunk {
//   ChunkElement elements[ChunkSize];
//   CyclicBuffer cyclicIndexBuffer;
// };
//
// void chunk_init(out Chunk self) {
//   cyclicBuffer_init(self);
// }
//
// void chunk_empty(in Chunk self) {
//   return cyclicBuffer_empty(self.cyclicIndexBuffer);
// }
//
// void chunk_peek(in Chunk self, out ChunkElement element) {
//   element = elements[cyclicBuffer_back()];
// }
//
// void chunk_next(in Chunk self) {
//   cyclicBuffer_popBack();
// }
//
// void chunk_restockFromHeavy(in Chunk self, in uint j, uint j1) {
//   uint size = cyclicBuffer_count(self.cyclicIndexBuffer);
//   uint emptySpace = CyclicBufferSize - size;
//
//   uint jx = j;
//   while (jx <= j1 && emptySpace != 0) {
//     float fetch = heavyLightIndices[jx++];
//     cyclicBuffer_pushFronts(self.cyclicIndexBuffer, fetch);
//     emptySpace--;
//   }
// }



void main(void) {
    uint k = gl_GlobalInvocationID.x;
    if (k >= pc.K) {
        return;
    }
    float spill;
    uint i0, j0;
    if (k == 0) {
        i0 = 0;
        j0 = 0;
        spill = 0;
    } else {
        i0 = splits[k - 1].i;
        j0 = splits[k - 1].j;
        spill = splits[k - 1].spill;
    }
    uint i1 = splits[k].i;
    uint j1 = splits[k].j;
    float averageWeight = mean;
    const uint N = pc.size;
    const uint heavyCount = heavyCount;
    const uint lightCount = N - heavyCount;
    const uint lastLightIndex = N - 1;

    uint i = i0;
    uint j = j0;

    float w = spill;
    if (w == 0.0f) {
        uint h = heavyLightIndices[j];
        w = weights[h];
    }

    while (i != i1 || j != j1) {
        bool packHeavy;
        // Checking bounds before the numerical comparision avoids
        // Floating point inaccuracies while comparing!
        if (j == j1) {
            // Only light buckets left.
            packHeavy = false;
        } else if (i == i1) {
            // Only heavy buckets left.
            packHeavy = true;
        } else {
            packHeavy = w <= averageWeight;
        }
        uint h = heavyLightIndices[j];
        uint weightIdx;
        if (packHeavy) {
            weightIdx = heavyLightIndices[j + 1];
        } else {
            weightIdx = heavyLightIndices[lastLightIndex - i];
        }
        float weight = weights[weightIdx];
        float p;
        uint idx, a;
        if (packHeavy) {
            // Pack heavy bucket!
            p = w / averageWeight;
            a = weightIdx;
            idx = h;
            j += 1;
        } else {
            // Pack light bucket
            p = weight / averageWeight;
            a = h;
            idx = weightIdx;
            i += 1;
        }
        table[idx].p = p;
        table[idx].a = a;
        w = (w + weight) - averageWeight;
    }
    if (j1 == heavyCount - 1) {
        // Last heavy element overal has to be handled seperately otherwise,
        // we access heavyIndices out of bound.
        // Maybe this would actually be fine because of our layout. Then the residual of the
        // last element which should always be zero, but numerical instabilities would be
        // reassigned to the last light element, both are probably fine, but here we choose to
        // redirect to not have the last heavy element redirect to anything makes it easier to debug!
        uint h = heavyLightIndices[j];
        table[h].p = 1.0f;
        table[h].a = h;
    }
}
