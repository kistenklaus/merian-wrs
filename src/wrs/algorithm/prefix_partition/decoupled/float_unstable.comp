#version 460

#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_memory_scope_semantics : enable
// #extension GL_EXT_shader_atomic_float : enable
#extension GL_KHR_shader_subgroup_vote : enable
// #extension GL_KHR_shader_subgroup_ballot : enable
#pragma use_vulkan_memory_model


// #define STABLE
// #define WRITE_PARTITION

#define monoid float
#define state_t uint
#define lbstate_t uint

layout(constant_id = 0) const uint GROUP_SIZE = 1;
layout(constant_id = 1) const uint SUBGROUP_SIZE = 1;
layout(constant_id = 2) const uint ROWS = 1;
const uint PARTITION_SIZE = GROUP_SIZE * ROWS;
const uint SUBGROUP_COUNT = (GROUP_SIZE + SUBGROUP_SIZE - 1) / SUBGROUP_SIZE;
layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

#define STATE_NO_AGGREGATE 0u
#define STATE_AGGREGATE 1u
#define STATE_PREFIX 2u
#define STATE_DONT_CARE 3u

struct BatchDescriptor {
    uint heavyCount;
    uint heavyCountInclusivePrefix;
    monoid heavySum;
    monoid heavyInclusivePrefix;
    monoid lightSum;
    monoid lightInclusivePrefix;
    state_t state;
};

layout(set = 0, binding = 0) readonly buffer in_values {
    monoid weights[];
};

layout(set = 0, binding = 1) readonly buffer in_pivot {
    monoid pivot;
};

layout(set = 0, binding = 2) volatile buffer batch_descriptors {
    uint atomicBatchCounter;
    BatchDescriptor batchInfo[];
};

layout(set = 0, binding = 3) writeonly buffer out_prefix {
    uint heavyCount;
    monoid heavyLightPrefix[];
};

layout(push_constant) uniform PushConstant {
    uint size;
} pc;

#define LOOK_BACK_STATE_SPIN 1u
#define LOOK_BACK_STATE_DONE 0u

shared uint sh_lookBackState;
shared uint sh_groupID;

shared uint sh_batchHeavyCountPrefix;
shared uint sh_heavyCountScratch[GROUP_SIZE + 1];

shared monoid sh_batchHeavyPrefix;
shared monoid sh_batchLightPrefix;
shared monoid sh_heavyScratch[GROUP_SIZE];
shared monoid sh_lightScratch[GROUP_SIZE];

#define ATOMIC_LOOK_BACK_STATE
#define ATOMIC_PARTITION_STATE

bool partitionPredicate(in monoid v, in monoid pivot) {
    // return true;
    return v > pivot;
}

uint partitionPredicateU(in monoid v, in monoid pivot) {
    return partitionPredicate(v, pivot) ? 1 : 0;
}

void main(void) {
    monoid localWeights[ROWS];
    monoid localHeavyPrefix[ROWS];
    monoid localLightPrefix[ROWS];
    bool localIsHeavy[ROWS];
    uint localHeavyCountExclusivePrefix[ROWS];

    const monoid pivot = pivot;
    const uint size = pc.size;

    const uint invocID = gl_LocalInvocationID.x;

    barrier();

    if (invocID == 0) {
        sh_groupID = atomicAdd(atomicBatchCounter, 1);
    }

    barrier();

    uint batchID = sh_groupID;
    const uint ix = batchID * PARTITION_SIZE + invocID * ROWS;

    for (uint i = 0; i < ROWS; ++i) {
        localWeights[i] = weights[ix + i];
        localIsHeavy[i] = partitionPredicate(localWeights[i], pivot);
    }

    localHeavyPrefix[0] = 0.0f;
    localLightPrefix[0] = 0.0f;
    if (localIsHeavy[0]) {
        localHeavyPrefix[0] = localWeights[0];
        localLightPrefix[0] = 0.0f;
    } else {
        localHeavyPrefix[0] = 0.0f;
        localLightPrefix[0] = localWeights[0];
    }
    for (uint i = 1; i < ROWS; ++i) {
        monoid h = localHeavyPrefix[i - 1];
        monoid l = localLightPrefix[i - 1];
        if (localIsHeavy[i]) {
            h += localWeights[i];
        } else {
            l += localWeights[i];
        }
        localHeavyPrefix[i] = h;
        localLightPrefix[i] = l;
    }
    const monoid localHeavySum = localHeavyPrefix[ROWS - 1];
    const monoid localLightSum = localLightPrefix[ROWS - 1];

    sh_heavyScratch[invocID] = localHeavySum;
    sh_lightScratch[invocID] = localLightSum;

    monoid batchHeavySum = localHeavySum;
    monoid batchLightSum = localLightSum;

    // 1. Step calculate local index exclusive prefix
    localHeavyCountExclusivePrefix[0] = 0;
    for (uint i = 0; i < ROWS - 1; ++i) {
        localHeavyCountExclusivePrefix[i + 1] = localHeavyCountExclusivePrefix[i] + (localIsHeavy[i] ? 1 : 0);
    }
    const uint localHeavyCount = localHeavyCountExclusivePrefix[ROWS - 1] + (localIsHeavy[ROWS - 1] ? 1 : 0);

    sh_heavyCountScratch[invocID + 1] = localHeavyCount;
    if (invocID == 0) {
        sh_heavyCountScratch[0] = 0;
    }

    uint batchHeavyCount = localHeavyCount;

    // 1.1 Workgroup exclusive prefix sum over rows
    // NOTE: We should definitly try the work efficient prefix sum algorithm here.

    for (uint shift = 1; shift <= gl_WorkGroupSize.x; shift <<= 1) {
        barrier();
        if (invocID >= shift) {
            uint otherHeavyCount = sh_heavyCountScratch[invocID - shift + 1];
            batchHeavyCount += otherHeavyCount;

            monoid otherHeavySum = sh_heavyScratch[invocID - shift];
            batchHeavySum += otherHeavySum;

            monoid otherLightSum = sh_lightScratch[invocID - shift];
            batchLightSum += otherLightSum;
        }
        barrier();
        sh_heavyCountScratch[invocID + 1] = batchHeavyCount;
        sh_heavyScratch[invocID] = batchHeavySum;
        sh_lightScratch[invocID] = batchLightSum;
    }

    // 2. Publish Aggregate and state
    // 2.1 Publish aggregate
    if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
        batchInfo[batchID].heavyCount = batchHeavyCount;
        batchInfo[batchID].heavySum = batchHeavySum;
        batchInfo[batchID].lightSum = batchLightSum;
        if (batchID == 0) {
            batchInfo[batchID].heavyCountInclusivePrefix = batchHeavyCount;
            batchInfo[batchID].heavyInclusivePrefix = batchHeavySum;
            batchInfo[batchID].lightInclusivePrefix = batchLightSum;
        }
    }

    // memoryBarrierBuffer();

    if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
        state_t state = STATE_AGGREGATE;
        if (batchID == 0) {
            state = STATE_PREFIX;
        }
        atomicStore(batchInfo[batchID].state, state, gl_ScopeQueueFamily,
            gl_StorageSemanticsBuffer, gl_SemanticsRelease);
    }

    uint batchHeavyCountPrefix = 0;
    monoid batchHeavySumExclusivePrefix = 0;
    monoid batchLightSumExclusivePrefix = 0;
    if (batchID != 0) {
        lbstate_t lookBackIndex = batchID - 1;
        sh_lookBackState = LOOK_BACK_STATE_SPIN;
        while (true) {
            state_t lookBatchState;
            if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
                lookBatchState = atomicLoad(batchInfo[lookBackIndex].state, gl_ScopeQueueFamily,
                        gl_StorageSemanticsBuffer, gl_SemanticsAcquire | gl_SemanticsMakeVisible);
                if (lookBatchState == STATE_AGGREGATE) {
                    batchHeavyCountPrefix += batchInfo[lookBackIndex].heavyCount;
#ifndef STABLE
                    batchHeavySumExclusivePrefix += batchInfo[lookBackIndex].heavySum;
                    batchLightSumExclusivePrefix += batchInfo[lookBackIndex].lightSum;
#endif
                    lookBackIndex--;
                    sh_lookBackState = LOOK_BACK_STATE_SPIN;
                } else if (lookBatchState == STATE_PREFIX) {
                    batchHeavyCountPrefix += batchInfo[lookBackIndex].heavyCountInclusivePrefix;
                    batchHeavySumExclusivePrefix += batchInfo[lookBackIndex].heavyInclusivePrefix;
                    batchLightSumExclusivePrefix += batchInfo[lookBackIndex].lightInclusivePrefix;
#ifdef STABLE
                    for (uint i = lookBackIndex + 1; i < batchID; ++i) {
                        batchLightSumExclusivePrefix += batchInfo[i].lightSum;
                        batchHeavySumExclusivePrefix += batchInfo[i].heavySum;
                    }
#endif

                    sh_lookBackState = LOOK_BACK_STATE_DONE;
                } else if (lookBatchState == STATE_NO_AGGREGATE) {
                    sh_lookBackState = LOOK_BACK_STATE_SPIN;
                }
            }
            barrier();
            lookBatchState = sh_lookBackState;
            if (lookBatchState == LOOK_BACK_STATE_DONE) {
                break;
            }
        }

        if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
            sh_batchHeavyCountPrefix = batchHeavyCountPrefix;
            sh_batchHeavyPrefix = batchHeavySumExclusivePrefix;
            sh_batchLightPrefix = batchLightSumExclusivePrefix;
            batchInfo[batchID].heavyCountInclusivePrefix = batchHeavyCountPrefix + batchHeavyCount;
            batchInfo[batchID].heavyInclusivePrefix = batchHeavySumExclusivePrefix + batchHeavySum;
            batchInfo[batchID].lightInclusivePrefix = batchLightSumExclusivePrefix + batchLightSum;
        }

        controlBarrier(gl_ScopeWorkgroup, gl_ScopeQueueFamily, gl_StorageSemanticsBuffer | gl_StorageSemanticsShared,
            gl_SemanticsAcquireRelease);

        if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1) {
            atomicStore(batchInfo[batchID].state, STATE_PREFIX,
                gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsRelease | gl_SemanticsMakeAvailable);
        } else {
            batchHeavyCountPrefix = sh_batchHeavyCountPrefix;
            batchHeavySumExclusivePrefix = sh_batchHeavyPrefix;
            batchLightSumExclusivePrefix = sh_batchLightPrefix;
        }
    }
    barrier();

    uint rowHeavyCountExclusivePrefix = batchHeavyCountPrefix;
#ifdef STABLE
    monoid rowHeavyExclusivePrefixSum = 0;
    monoid rowLightExclusivePrefixSum = 0;
#else
    monoid rowHeavyExclusivePrefixSum = batchHeavySumExclusivePrefix;
    monoid rowLightExclusivePrefixSum = batchLightSumExclusivePrefix;
#endif

    // memoryBarrierBuffer(); // trying to ensure numerical stability.
    if (invocID > 0) {
        rowHeavyCountExclusivePrefix += sh_heavyCountScratch[invocID];
        rowHeavyExclusivePrefixSum += sh_heavyScratch[invocID - 1];
        // rowLightExclusivePrefixSum += sh_lightScratch[invocID - 1];

        monoid x = rowLightExclusivePrefixSum + sh_lightScratch[invocID - 1];
        // monoid y = rowLightExclusivePrefixSum + sh_lightScratch[invocID];
        // monoid m = min(x, y);
        rowLightExclusivePrefixSum = x;
    }
    for (uint i = 0; i < ROWS; ++i) {
        if (ix + i < size) {
            uint h = rowHeavyCountExclusivePrefix + localHeavyCountExclusivePrefix[i]; //flagged element prefix
            uint index = h;
            if (!localIsHeavy[i]) {
                uint l = (ix + i) - h; // unflagged element prefix
                index = (size - 1) - l;
            }
#ifdef WRITE_PARTITION
            heavyLightPartition[index] = localWeights[i];
#endif

            if (localIsHeavy[i]) {
                monoid heavyPrefix = rowHeavyExclusivePrefixSum + localHeavyPrefix[i];
#ifdef STABLE
                heavyPrefix += batchHeavySumExclusivePrefix;
#endif
                heavyLightPrefix[index] = heavyPrefix;
            } else {
                monoid lightPrefix = rowLightExclusivePrefixSum + localLightPrefix[i];
#ifdef STABLE
                lightPrefix += batchLightSumExclusivePrefix;
#endif
                heavyLightPrefix[index] = lightPrefix;
            }
            // NOTE: Does not have to be in the loop only has the performed for the last batch
            if (ix + i == size - 1) {
                if (localIsHeavy[i]) {
                    heavyCount = h + 1;
                } else {
                    heavyCount = h;
                }
            }
        }
    }
}
