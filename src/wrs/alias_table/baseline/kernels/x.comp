#version 460

#define weight_t float
#define state_t uint
#define STATE_RESULT_FOUND 0
#define STATE_CONTINUE_LEFT 1
#define STATE_CONTINUE_RIGHT 2

#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_memory_scope_semantics : enable
// #extension GL_EXT_shader_atomic_float : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#pragma use_vulkan_memory_model

layout(constant_id = 0) const uint SUBGROUP_SIZE = 1;
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer in_values {
    weight_t weights[];
};

layout(set = 0, binding = 1) readonly buffer out_average_and_prefix_sum {
    weight_t average;
    weight_t prefix_sum[];
};

layout(set = 0, binding = 2) readonly buffer out_partition {
    uint heavyCount;
    weight_t heavyLightPartition[];
};

layout(set = 0, binding = 3) readonly buffer out_prefix {
    weight_t heavyLightPrefix[];
};

struct SplitDescription {
    uint heavyOffset;
    uint lightOffset;
    weight_t spill;
};

layout(set = 0, binding = 4) writeonly buffer out_splits {
    SplitDescription splitDescriptions[];
};

layout(push_constant) uniform PushConstant {
    uint N; //amount of weights
    uint K; //amount of splits
} pc;

int h_size;
int l_size;
int N;

weight_t getHeavyPrefix(uint j) {
    if (j > 0) {
        return heavyLightPrefix[j - 1];
    } else {
        return 0.0f;
    }
}

weight_t getLightPrefix(uint i) {
    if (i > 0) {
        return heavyLightPrefix[N - (i - 1)];
    } else {
        return 0.0f;
    }
}


void main(void)
{
    const uint k = gl_WorkGroupID.x;
    N = int(pc.N);
    const int K = int(pc.K);
    h_size = int(heavyCount);
    l_size = N - l_size;

    if (gl_WorkGroupID.x == 0) {
        if (subgroupElect()) {
            splitDescriptions[k].heavyOffset = 0;
            splitDescriptions[k].lightOffset = 0;
            splitDescriptions[k].spill = 0.0f;
        }
        return;
    } else if (gl_WorkGroupID.x == K - 1) {
        if (subgroupElect()) {
            splitDescriptions[k].heavyOffset = N;
            splitDescriptions[k].lightOffset = N;
            splitDescriptions[k].spill = 0.0f;
        }
        return;
    }
    const uint K_ = K - 2;
    const uint n_ = N * k;
    const int n = int((n_ + K_ - 1) / K_);
    const weight_t W = average * n;

    int a = 1; // inclusive
    int b = int(min(n, heavyCount)); // inclusive

    uint it = 0;
    uint aStep = 0;
    uint bStep = 0;
    while (true) {
        it += 1;

        const int j = (a + b) / 2; //Amount of heavy items
        const int i = min(n - j, l_size); // Amount of light items

        if () {
          b = j - 1;
        } else if (i - 1>= h_size || j - 1< 0) {
          a = j + 1;
        }

        weight_t l_prefix = getLightPrefix(i);

        weight_t h_prefix = getHeavyPrefix(j);

        weight_t sigma = l_prefix + h_prefix;
        if (sigma <= W) {
            weight_t sigmaNext = getLightPrefix(i - 1)
                    + getHeavyPrefix(j + 1);
            if (sigmaNext > W) {
                if (subgroupElect()) {
                    splitDescriptions[k].heavyOffset = j;
                    splitDescriptions[k].lightOffset = i;
                    splitDescriptions[k].spill = 
                      sigma + heavyLightPartition[j] - W;
                }
                break;
            } else {
                aStep += 1;
                a = j + 1;
            }
        } else {
            bStep += 1;
            b = j - 1;
        }

        subgroupBarrier();
        if (it > 10000) {
            if (subgroupElect()) {
                splitDescriptions[k].heavyOffset = 0;
                splitDescriptions[k].lightOffset = 0;
                splitDescriptions[k].spill = 7;
            }
            break;
        }
    }
}
